
// Mina elliptic cruve unit tests
//
//    Imported from https://github.com/MinaProtocol/c-reference-signer/blob/master/curve_checks.c
//    Do not edit this file

#include <string.h>

#include "curve_checks.h"

#ifdef LEDGER_BUILD
#define CHECK_FAIL return false;
#else
#define CHECK_FAIL fprintf(stderr, "\n!! FAILED %s() at %s:%d !!\n\n", \
                         __FUNCTION__, __FILE__, __LINE__); \
                   return false;
#endif

bool curve_checks(void)
{
    Affine a3;
    Affine a4;
    union {
        // Fit in stackspace!
        Affine a5;
        Scalar s2;
    } u;

    for (size_t i = 0; i < EPOCHS; i++) {
        // Test1: On curve after scaling
        if (!affine_is_on_curve(&A[i][0])) {
            CHECK_FAIL;
        }
        if (!affine_is_on_curve(&A[i][1])) {
            CHECK_FAIL;
        }
        if (!affine_is_on_curve(&A[i][2])) {
            CHECK_FAIL;
        }

        // Test2: Addition is commutative
        //     A0 + A1 == A1 + A0
        affine_add(&a3, &A[i][0], &A[i][1]); // a3 = A0 + A1
        affine_add(&a4, &A[i][1], &A[i][0]); // a4 = A1 + A0
        if (!affine_eq(&a3, &a4)) {
            CHECK_FAIL;
        }
        if (!affine_is_on_curve(&a3)) {
            CHECK_FAIL;
        }
        // Test target check: a3 == T0
        if (memcmp(&a3, &T[i][0], sizeof(a3)) != 0) {
            CHECK_FAIL;
        }

        // Test3: Scaling commutes with adding scalars
        //     G*(S0 + S1) == G*S0 + G*S1
        scalar_add(u.s2, S[i][0], S[i][1]);
        generate_pubkey(&a3, u.s2);          // a3 = G*(S0 + S1)
        affine_add(&a4, &A[i][0], &A[i][1]); // a4 = G*S0 + G*S1
        if (!affine_eq(&a3, &a4)) {
            CHECK_FAIL;
        }
        if (!affine_is_on_curve(&a3)) {
            CHECK_FAIL;